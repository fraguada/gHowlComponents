using System;
using System.Collections.Generic;

using Grasshopper.Kernel;
using Rhino.Geometry;
using gHowl.Properties;
using Grasshopper.Kernel.Data;
using Grasshopper.Kernel.Types;
using System.Drawing;
using Rhino.DocObjects;
using SharpKml.Dom;
using SharpKml.Engine;
using SharpKml.Base;

namespace gHowl.KML
{
    public class KMLExportComponent : GH_Component
    {
        /// <summary>
        /// Initializes a new instance of the MyComponent1 class.
        /// </summary>
        public KMLExportComponent()
            : base("Export KML", "KML->", "Export geometry to KML format", "gHowl", "KML")
        {
            this.Message = "Absolute";
            this.SetValue("Absolute", true);
            this.SetValue("ClampToGround", false);
            this.SetValue("RelativeToGround", false);
            this.ValuesChanged();
            
        }

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {

            pManager.AddTextParameter("File Path", "F", "File to write to *.KML", GH_ParamAccess.item);
            pManager.AddGeometryParameter("Geometry", "G", "Geometry to export", GH_ParamAccess.tree);

            KMLStyleParameter param = new KMLStyleParameter();
            param.SetPersistentData(new KMLStyleType());
            pManager.AddParameter(param, "Style", "S", "KML Object Style", GH_ParamAccess.tree);
            

            pManager.AddPointParameter("XYZ Coordinate Reference", "XYZ", "Reference Point Model Coordinates", GH_ParamAccess.item);
            pManager.AddPointParameter("GPS Coordinate Reference", "GEO", "Reference Point Geographic Coordinates in D.D. Longitude, Latitude, Altitude", GH_ParamAccess.item);
          

            pManager[0].Optional = false;
            pManager[1].Optional = false;
            pManager[2].Optional = true;
            pManager[3].Optional = false;
            pManager[4].Optional = false;
       
        }

        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {

        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {

            //variables from inputs
            string file = "";
            GH_Structure<IGH_GeometricGoo> geoGoo, geo = new GH_Structure<IGH_GeometricGoo>();
            GH_Structure<KMLStyleType> stylesIn, styles = new GH_Structure<KMLStyleType>();
            Point3d EAP_GPS = new Point3d();
            Point3d EAP_XYZ = new Point3d();
            //string altMode = "";

            //Get Required Inputs
            if ((!DA.GetData(0, ref file)) || file == null ||
                (!DA.GetDataTree<IGH_GeometricGoo>(1, out geoGoo)) || geoGoo == null || geoGoo.IsEmpty ||
                (!DA.GetData(3, ref EAP_XYZ)) || EAP_XYZ == null ||
                (!DA.GetData(4, ref EAP_GPS)) || EAP_GPS == null 
                
                 )
            {

                return;
            }

            AltitudeMode altModeEnum = new AltitudeMode();
            //if (altMode == "absolute")
            if(this.GetValue("Absolute",false))
            {
                altModeEnum = AltitudeMode.Absolute;
            }
            else if (this.GetValue("ClampToGround", false))
            {
                altModeEnum = AltitudeMode.ClampToGround;
            }
            else if (this.GetValue("RelativeToGround", false))
            {
                altModeEnum = AltitudeMode.RelativeToGround;
            }
            else
            {
                altModeEnum = AltitudeMode.Absolute;
                AddRuntimeMessage(GH_RuntimeMessageLevel.Warning, "Altitude Mode not understood, defaulting to absolute \nUse \"absolute\",\"clampToGround\", or \"relativeToGround\"");
            }

            //Optional Inputs
            DA.GetDataTree<KMLStyleType>(2, out stylesIn);

            //Set up EAP 

            EarthAnchorPoint eap = new EarthAnchorPoint();
            eap.EarthBasepointLongitude = EAP_GPS.X;
            eap.EarthBasepointLatitude = EAP_GPS.Y;
            eap.EarthBasepointElevation = EAP_GPS.Z;
            eap.ModelBasePoint = EAP_XYZ;

            Rhino.UnitSystem us = new Rhino.UnitSystem();

            Transform xf = eap.GetModelToEarthTransform(us);



            Folder f = new Folder();
            f.Name = "generated by gHowl";

            Folder f_points = new Folder();
            f_points.Name = "Points";

            Folder f_curves = new Folder();
            f_curves.Name = "Curves";

            Folder f_poly = new Folder();
            f_poly.Name = "Poly";

            bool b_pts = false;
            bool b_crv = false;
            bool b_poly = false;

            bool match = false;

            geo = geoGoo.Duplicate();
            styles = stylesIn;
            Document doc = new Document();
            if (geo.PathCount != styles.PathCount || geo.DataCount != styles.DataCount)
            {
                AddRuntimeMessage(GH_RuntimeMessageLevel.Warning, "Number of objects and styles do not match.");
                match = false;
            }
            else { match = true; }


            Point3d ptGeo = Point3d.Unset;
            Placemark placemark = new Placemark();
            
          
            //hangle geometry
            for (int i = 0; i < geo.PathCount; i++)
            {

                for (int j = 0; j < geo.get_Branch(i).Count; j++)
                {
                    

                    IGH_GeometricGoo geoGooObj = geo[i][j];

                    //Handle Styles
                    Style s = new Style();
                    s.Line = new LineStyle();
                    s.Polygon = new PolygonStyle();
                    s.Icon = new IconStyle();
                    KMLStyleType kmlStyle = new KMLStyleType();

                    if (match)
                    {
                        kmlStyle = styles[i][j];//styles.get_DataItem(geo.Paths[i],j);
                        
                    }
                    else 
                    {
                        if ((styles.PathCount == geo.PathCount) && (styles[i].Count > 0)) 
                        {
                            kmlStyle = styles[i][0];
                        }
                        else if(styles.DataCount>0)
                        {
                            kmlStyle = new KMLStyleType(System.Drawing.ColorTranslator.FromHtml(styles[0][0].fillColor), System.Drawing.ColorTranslator.FromHtml(styles[0][0].lineColor), styles[0][0].lineWidth,"");
                        } else
                        {
                            kmlStyle = new KMLStyleType(Color.White, Color.Black, 1.0,"");
                        }
                    }

                    s.Icon.Color = Color32.Parse(kmlStyle.fillColor);
                    s.Polygon.Fill = true;
                    s.Polygon.ColorMode = ColorMode.Normal;
                    s.Polygon.Color = Color32.Parse(kmlStyle.fillColor);
                    s.Line.Color = Color32.Parse(kmlStyle.lineColor);
                    s.Line.ColorMode = ColorMode.Normal;
                    s.Line.Width = kmlStyle.lineWidth;
                    
                    doc.AddStyle(s);

                    GeometryBase geoObj = GH_Convert.ToGeometryBase(geoGooObj);

                    switch (geoObj.ObjectType)
                    {
                        case Rhino.DocObjects.ObjectType.Point:
                            b_pts = true;
                            Rhino.Geometry.Point pt = (Rhino.Geometry.Point)geoObj;
                            ptGeo = processPt(new Point3d(pt.Location.X, pt.Location.Y, pt.Location.Z), xf);

                            SharpKml.Dom.Point point = new SharpKml.Dom.Point();
                            point.Coordinate = new SharpKml.Base.Vector(ptGeo.Y, ptGeo.X, ptGeo.Z);

                            point.AltitudeMode = altModeEnum;

                            placemark = new Placemark();
                            placemark.Geometry = point;
                            placemark.Name = kmlStyle.name;//"PT_" + j.ToString(); //add a better way to add specific text
                            placemark.StyleSelector = s;
                            f_points.AddFeature(placemark);

                            break;

                        case Rhino.DocObjects.ObjectType.Curve:
                            b_crv = true;

                            Rhino.Geometry.Curve crv = (Rhino.Geometry.Curve)geoObj;
                            CoordinateCollection pts = new CoordinateCollection();
                            if (crv.IsPolyline())
                            {
                                Rhino.Geometry.Polyline pLine;
                                crv.TryGetPolyline(out pLine);
                                Point3d[] ptArr = pLine.ToArray();

                                //CoordinateCollection pts = new CoordinateCollection();

                                for (int p = 0; p < ptArr.Length; p++)
                                {

                                    ptGeo = processPt(ptArr[p], xf);
                                    // AddRuntimeMessage(GH_RuntimeMessageLevel.Warning, ptGeo.ToString());
                                    pts.Add(new SharpKml.Base.Vector(ptGeo.Y, ptGeo.X, ptGeo.Z));

                                }

                            }
                            else
                            {
                                Point3d[] ptArr;
                                //need to devise a way to control this
                                AddRuntimeMessage(GH_RuntimeMessageLevel.Warning, "Converting the curve to a polyline.  If you want to control this, convert the curve to a polyline before using this component.");
                           
                                crv.DivideByCount((int)(crv.GetLength() / 10), true, out ptArr);

                                for (int p = 0; p < ptArr.Length; p++)
                                {
                                    ptGeo = processPt(ptArr[p], xf);
                                    pts.Add(new SharpKml.Base.Vector(ptGeo.Y, ptGeo.X, ptGeo.Z));

                                }

                            }
                            LineString ls = new LineString();
                            ls.Coordinates = pts;
                            ls.AltitudeMode = altModeEnum;
                            placemark = new Placemark();
                            placemark.Geometry = ls;
                            //placemark.Name = "Curve"; //add a better way to add specific text
                            placemark.Name = kmlStyle.name;
                            placemark.StyleSelector = s;
                            
                            f_curves.AddFeature(placemark);
                            break;

                        case Rhino.DocObjects.ObjectType.Surface:
                            b_poly = true;

                            
                            AddRuntimeMessage(GH_RuntimeMessageLevel.Warning, "Converting the surface to a mesh.  If you want to control this, convert the surface to a mesh before using this component.");
                            
                            Rhino.Geometry.Surface srf = (Rhino.Geometry.Surface)geoObj;
                            Rhino.Geometry.Brep brp = srf.ToBrep();
                            Mesh[] m = Mesh.CreateFromBrep(brp, MeshingParameters.Default);
                            Mesh mesh = new Mesh();
                            foreach (Mesh _m in m)
                            {
                                mesh.Append(_m);
                            }

                            MultipleGeometry mg = meshToMG(mesh, altModeEnum, xf);

                            placemark = new Placemark();
                            placemark.Geometry = mg;
                            //placemark.Name = "Poly"; //add a better way to add specific text
                            placemark.Name = kmlStyle.name;
                            placemark.StyleSelector = s;
                            f_poly.AddFeature(placemark);

                            break;

                        case Rhino.DocObjects.ObjectType.Brep:

                            b_poly = true;

                            AddRuntimeMessage(GH_RuntimeMessageLevel.Warning, "Converting the brep to a mesh.  If you want to control this, convert the brep to a mesh before using this component.");

                            Rhino.Geometry.Brep brp2 = (Rhino.Geometry.Brep)geoObj;
                            Mesh[] m2 = Mesh.CreateFromBrep(brp2, MeshingParameters.Default);
                            Mesh mesh2 = new Mesh();

                            foreach (Mesh _m in m2)
                            {
                                mesh2.Append(_m);
                            }

                            MultipleGeometry mg2 = meshToMG(mesh2, altModeEnum, xf);

                            placemark = new Placemark();
                            placemark.Geometry = mg2;
                            //placemark.Name = "Poly"; //add a better way to add specific text
                            placemark.Name = kmlStyle.name;
                            placemark.StyleSelector = s;
                            f_poly.AddFeature(placemark);

                            break;
                        case Rhino.DocObjects.ObjectType.Mesh:
                            b_poly = true;

                            Rhino.Geometry.Mesh mesh3 = (Rhino.Geometry.Mesh)geoObj;

                            MultipleGeometry mg3 = meshToMG(mesh3, altModeEnum, xf);

                            placemark = new Placemark();
                            placemark.Geometry = mg3;
                            //placemark.Name = "Poly"; //add a better way to add specific text
                            placemark.Name = kmlStyle.name;
                            placemark.StyleSelector = s;
                            f_poly.AddFeature(placemark);

                            break;

                        default:
                            AddRuntimeMessage(GH_RuntimeMessageLevel.Error, geoObj.ObjectType.ToString() + " type not supported");
                            break;

                    }
                }
            }


            if (b_pts)
            {
                f.AddFeature(f_points);
            }

            if (b_crv)
            {
                f.AddFeature(f_curves);
            }

            if (b_poly)
            {
                f.AddFeature(f_poly);
            }


            doc.AddFeature(f);
            Kml kml = new Kml();
            kml.Feature = doc;
            doc.Name = file;
            KmlFile kmlFile = KmlFile.Create(kml, false);

            kmlFile.Save(file);
        }

        /// <summary>
        /// Transform points from Rhino Coordinates to World Coordinates
        /// </summary>
        public Point3d processPt(Point3d pt, Transform xf)
        {
            Point3d ptON = new Point3d(pt.X, pt.Y, pt.Z);
            ptON = xf * ptON; //where the magic happens
            Point3d ptOut = new Point3d(ptON.X, ptON.Y, ptON.Z);
            return ptOut;
        }

        public MultipleGeometry meshToMG(Mesh mesh, AltitudeMode altModeEnum, Transform xf)
        {
            MultipleGeometry mg = new MultipleGeometry();
            Rhino.Geometry.Collections.MeshFaceList mfl = mesh.Faces;
            Rhino.Geometry.Collections.MeshVertexList mvl = mesh.Vertices;

            for (int q = 0; q < mfl.Count; q++)
            {

                CoordinateCollection pts = new CoordinateCollection();

                Rhino.Geometry.MeshFace mf = mfl[q];

                if (mf.IsTriangle)
                {
                    Point3d ptA = processPt(mvl[mf.A], xf);
                    pts.Add(new SharpKml.Base.Vector(ptA.Y, ptA.X, ptA.Z));
                    Point3d ptB = processPt(mvl[mf.B], xf);
                    pts.Add(new SharpKml.Base.Vector(ptB.Y, ptB.X, ptB.Z));
                    Point3d ptC = processPt(mvl[mf.C], xf);
                    pts.Add(new SharpKml.Base.Vector(ptC.Y, ptC.X, ptC.Z));
                    Point3d ptD = processPt(mvl[mf.D], xf);
                    pts.Add(new SharpKml.Base.Vector(ptD.Y, ptD.X, ptD.Z));


                }
                else
                {
                    Point3d ptA = processPt(mvl[mf.A], xf);
                    pts.Add(new SharpKml.Base.Vector(ptA.Y, ptA.X, ptA.Z));
                    Point3d ptB = processPt(mvl[mf.B], xf);
                    pts.Add(new SharpKml.Base.Vector(ptB.Y, ptB.X, ptB.Z));
                    Point3d ptC = processPt(mvl[mf.C], xf);
                    pts.Add(new SharpKml.Base.Vector(ptC.Y, ptC.X, ptC.Z));
                    Point3d ptD = processPt(mvl[mf.D], xf);
                    pts.Add(new SharpKml.Base.Vector(ptD.Y, ptD.X, ptD.Z));
                }

                Polygon pgon = new Polygon();
                pgon.AltitudeMode = altModeEnum;
                OuterBoundary ob = new OuterBoundary();
                LinearRing lr = new LinearRing();
                lr.Coordinates = pts;
                ob.LinearRing = lr;
                //ob.LinearRing.Coordinates = pts;
                pgon.OuterBoundary = ob;
                mg.AddGeometry(pgon);
            }

            return mg;

        }

        public override void AppendAdditionalMenuItems(System.Windows.Forms.ToolStripDropDown menu)
        {
            base.AppendAdditionalMenuItems(menu);
            
            Menu_AppendItem(menu, "Absolute", new EventHandler(this.Menu_AbsoluteClicked), true, this.GetValue("Absolute", true)).ToolTipText = "Interpret the altitude as a value in meters relative to the vertical datum.";
            Menu_AppendItem(menu, "Clamp To Ground", new EventHandler(this.Menu_ClampToGroundClicked), true, this.GetValue("ClampToGround", false)).ToolTipText = "Ignore the altitude specification.";
            Menu_AppendItem(menu, "Relative To Ground", new EventHandler(this.Menu_RelativeToGroundClicked), true, this.GetValue("RelativeToGround", false)).ToolTipText = "Interpret the altitude in meters relative to the terrain elevation.";
        }

        private void Menu_AbsoluteClicked(object sender, EventArgs e)
        {
            //this.SetValue("Absolute", !this.GetValue("Absolute", false));
            this.SetValue("Absolute", true);
            this.SetValue("ClampToGround", false);
            this.SetValue("RelativeToGround", false);

            this.ExpireSolution(true);
        }

        private void Menu_ClampToGroundClicked(object sender, EventArgs e)
        {
            //this.SetValue("ClampToGround", !this.GetValue("ClampToGround", false));
            this.SetValue("Absolute", false);
            this.SetValue("ClampToGround", true);
            this.SetValue("RelativeToGround", false);
            this.ExpireSolution(true);
        }

        private void Menu_RelativeToGroundClicked(object sender, EventArgs e)
        {
            //this.SetValue("RelativeToGround", !this.GetValue("RelativeToGround", false));
            this.SetValue("Absolute", false);
            this.SetValue("ClampToGround", false);
            this.SetValue("RelativeToGround", true);
            this.ExpireSolution(true);
        }


        protected override void ValuesChanged()
        {
            if (this.GetValue("Absolute", false))
            {
                this.Message = "Absolute";
            }
            else if (this.GetValue("ClampToGround", false))
            {
                this.Message = "Clamp To Ground";
            }
            else if (this.GetValue("RelativeToGround", false))
            {
                this.Message = "Relative To Ground";
            }
        }



        /// <summary>
        /// Provides an Icon for the component.
        /// </summary>
        protected override System.Drawing.Bitmap Icon
        {
            get
            {
                //You can add image files to your project resources and access them like this:
                return Resources.geIcon;
                //return null;
            }
        }

        /// <summary>
        /// Gets the unique ID for this component. Do not change this ID after release.
        /// </summary>
        public override Guid ComponentGuid
        {
            get { return new Guid("{f918b26e-f200-4099-8654-8ed730612ebe}"); }
        }
    }
}